"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccessKey = exports.DeleteAccount = exports.DeleteKey = exports.AddKey = exports.Stake = exports.Transfer = exports.FunctionCall = exports.DeployContract = exports.Action = exports.ReceiptKind = exports.Receipt = void 0;
const events_1 = require("./events");
/**
 * This field is a simplified representation of the `ReceiptView` structure from [near-primitives](https://github.com/near/nearcore/tree/master/core/primitives).
 */
class Receipt {
    constructor(
    /**
     * Defined the type of the `Receipt`: `Action` or `Data` representing the `ActionReceipt` and `DataReceipt`.
     */
    receiptKind, 
    /**
     * The ID of the `Receipt` of the `CryptoHash` type.
     */
    receiptId, 
    /**
     * The receiver account id of the `Receipt`.
     */
    receiverId, 
    /**
     * The predecessor account id of the `Receipt`.
     */
    predecessorId, 
    /**
     * Represents the status of `ExecutionOutcome` of the `Receipt`.
     */
    status, 
    /**
     * The id of the `ExecutionOutcome` for the `Receipt`. Returns `null` if the `Receipt` isn’t executed yet and has a postponed status.
     */
    executionOutcomeId, 
    /**
     * The original logs of the corresponding `ExecutionOutcome` of the `Receipt`.
     *
     * **Note:** not all the logs might be parsed as JSON Events (`Events`).
     */
    logs = []) {
        this.receiptKind = receiptKind;
        this.receiptId = receiptId;
        this.receiverId = receiverId;
        this.predecessorId = predecessorId;
        this.status = status;
        this.executionOutcomeId = executionOutcomeId;
        this.logs = logs;
    }
    /**
     * Returns an Array of `Events` for the `Receipt`, if any. This might be empty if the `logs` field is empty or doesn’t contain JSON Events compatible log records.
     */
    get events() {
        return this.logs
            .filter((log) => events_1.RawEvent.isEvent(log))
            .map((log) => events_1.Event.fromLog(log, this.receiptId));
    }
}
exports.Receipt = Receipt;
Receipt.fromOutcomeWithReceipt = (outcomeWithReceipt) => {
    var _b, _c;
    const kind = "Action" in outcomeWithReceipt.receipt
        ? ReceiptKind.Action
        : ReceiptKind.Data;
    return new Receipt(kind, outcomeWithReceipt.receipt.receiptId, (_b = outcomeWithReceipt.receipt) === null || _b === void 0 ? void 0 : _b.receiverId, (_c = outcomeWithReceipt.receipt) === null || _c === void 0 ? void 0 : _c.predecessorId, outcomeWithReceipt.executionOutcome.outcome.status, outcomeWithReceipt.executionOutcome.id, outcomeWithReceipt.executionOutcome.outcome.logs);
};
/**
 * `ReceiptKind` a simple `enum` to represent the `Receipt` type: either `Action` or `Data`.
 */
var ReceiptKind;
(function (ReceiptKind) {
    ReceiptKind["Action"] = "Action";
    ReceiptKind["Data"] = "Data";
})(ReceiptKind = exports.ReceiptKind || (exports.ReceiptKind = {}));
/**
 * `Action` is the structure with the fields and data relevant to an `ActionReceipt`.
 *
 * Basically, `Action` is the structure that indexer developers will be encouraged to work the most in their action-oriented indexers.
 */
class Action {
    constructor(
    /**
     * The id of the corresponding `Receipt`
     */
    receiptId, 
    /**
     * The status of the corresponding `Receipt`
     */
    receiptStatus, 
    /**
     * The predecessor account id of the corresponding `Receipt`.
     * This field is a piece of denormalization of the structures (`Receipt` and `Action`).
     */
    predecessorId, 
    /**
     * The receiver account id of the corresponding `Receipt`.
     * This field is a piece of denormalization of the structures (`Receipt` and `Action`).
     */
    receiverId, 
    /**
     * The signer account id of the corresponding `Receipt`
     */
    signerId, 
    /**
     * The signer’s PublicKey for the corresponding `Receipt`
     */
    signerPublicKey, 
    /**
     * An array of `Operation` for this `ActionReceipt`
     */
    operations, 
    /**
     * An array of log messages for this `ActionReceipt`
     */
    logs = []) {
        this.receiptId = receiptId;
        this.receiptStatus = receiptStatus;
        this.predecessorId = predecessorId;
        this.receiverId = receiverId;
        this.signerId = signerId;
        this.signerPublicKey = signerPublicKey;
        this.operations = operations;
        this.logs = logs;
    }
    /**
     * An array of events complying to NEP-0297 standard for this `ActionReceipt`
     */
    get events() {
        return this.logs
            .filter(events_1.RawEvent.isEvent)
            .map((log) => events_1.Event.fromLog(log, this.receiptId));
    }
}
exports.Action = Action;
_a = Action;
Action.isActionReceipt = (receipt) => {
    return (typeof receipt.receipt === "object" &&
        Object(receipt.receipt).hasOwnProperty("Action"));
};
Action.fromOutcomeWithReceipt = (outcomeWithReceipt) => {
    if (!_a.isActionReceipt(outcomeWithReceipt.receipt))
        return null;
    const receiptView = outcomeWithReceipt.receipt;
    const { Action: action } = receiptView.receipt;
    return new Action(receiptView.receiptId, outcomeWithReceipt.executionOutcome.outcome.status, receiptView.predecessorId, receiptView.receiverId, action.signerId, action.signerPublicKey, action.actions.map((a) => a), outcomeWithReceipt.executionOutcome.outcome.logs);
};
class DeployContract {
    constructor(code) {
        this.code = code;
    }
}
exports.DeployContract = DeployContract;
class FunctionCall {
    constructor(methodName, args, gas, deposit) {
        this.methodName = methodName;
        this.args = args;
        this.gas = gas;
        this.deposit = deposit;
    }
}
exports.FunctionCall = FunctionCall;
class Transfer {
    constructor(deposit) {
        this.deposit = deposit;
    }
}
exports.Transfer = Transfer;
class Stake {
    constructor(stake, publicKey) {
        this.stake = stake;
        this.publicKey = publicKey;
    }
}
exports.Stake = Stake;
class AddKey {
    constructor(publicKey, accessKey) {
        this.publicKey = publicKey;
        this.accessKey = accessKey;
    }
}
exports.AddKey = AddKey;
class DeleteKey {
    constructor(publicKey) {
        this.publicKey = publicKey;
    }
}
exports.DeleteKey = DeleteKey;
class DeleteAccount {
    constructor(beneficiaryId) {
        this.beneficiaryId = beneficiaryId;
    }
}
exports.DeleteAccount = DeleteAccount;
class AccessKey {
    constructor(nonce, permission) {
        this.nonce = nonce;
        this.permission = permission;
    }
}
exports.AccessKey = AccessKey;
class AccessKeyFunctionCallPermission {
    constructor(allowance, receiverId, methodNames) {
        this.allowance = allowance;
        this.receiverId = receiverId;
        this.methodNames = methodNames;
    }
}
