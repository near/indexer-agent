"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const src_1 = require("../src");
const helpers_1 = require("./helpers");
describe("Block", () => {
    it("serializes meta transactions", () => __awaiter(void 0, void 0, void 0, function* () {
        const block = yield (0, helpers_1.getBlock)(105793821);
        const actions = block.actionByReceiptId("Dpego7SpsK36PyXjUMrFoSze8ZpNsB9xhb3XJJYtXSix");
        expect(actions === null || actions === void 0 ? void 0 : actions.operations[0]).toMatchSnapshot();
    }));
    it("parses event logs", () => __awaiter(void 0, void 0, void 0, function* () {
        const block = yield (0, helpers_1.getBlock)(61321189);
        expect(block.events()).toMatchSnapshot();
    }));
    function base64toHex(encodedValue) {
        let buff = Buffer.from(encodedValue, "base64");
        return buff.toString("hex");
    }
    it("deserializes using borsch", () => __awaiter(void 0, void 0, void 0, function* () {
        const block = yield (0, helpers_1.getBlock)(114158749);
        const stateChanges = block.streamerMessage.shards
            .flatMap((e) => e.stateChanges)
            .filter((stateChange) => stateChange.change.accountId === "devgovgigs.near" &&
            stateChange.type === "data_update");
        const addOrEditPost = stateChanges
            .map((stateChange) => stateChange.change)
            .filter((change) => base64toHex(change.keyBase64).startsWith("05"))
            .map((c) => ({
            k: Buffer.from(c.keyBase64, "base64"),
            v: Buffer.from(c.valueBase64, "base64"),
        }));
        const authorToPostId = Object.fromEntries(addOrEditPost.map((kv) => {
            return [
                kv.v
                    .slice(13, 13 + kv.v.slice(9, 13).readUInt32LE())
                    .toString("utf-8"),
                Number(kv.k.slice(1).readBigUInt64LE()),
            ];
        }));
        expect(src_1.borsh.fromBorsh("u64", addOrEditPost[0].k.slice(1)) ===
            addOrEditPost[0].k.slice(1).readBigUInt64LE());
        expect(src_1.borsh.fromBorsh("u32", addOrEditPost[0].v.slice(9, 13)) ===
            addOrEditPost[0].v.slice(9, 13).readUInt32LE());
        expect(authorToPostId).toMatchSnapshot();
    }));
});
