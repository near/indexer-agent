import * as borsh from 'borsh';

interface StructFields {
    [k: string]: BorshSchema;
}
interface EnumVariants {
    [k: string]: BorshSchema;
}
declare class BorshSchema {
    private readonly schema;
    private constructor();
    static from(schema: borsh.Schema): BorshSchema;
    into(): borsh.Schema;
    /**
     * Schema for u8.
     * @example
     * const n: number = 100;
     *
     * const buffer = borshSerialize(BorshSchema.u8, n);
     */
    static get u8(): BorshSchema;
    /**
     * Schema for u16.
     * @example
     * const n: number = 100;
     *
     * const buffer = borshSerialize(BorshSchema.u16, n);
     */
    static get u16(): BorshSchema;
    /**
     * Schema for u32.
     * @example
     * const n: number = 100;
     *
     * const buffer = borshSerialize(BorshSchema.u32, n);
     */
    static get u32(): BorshSchema;
    /**
     * Schema for u64.
     * @example
     * const n: bigint = 100n;
     *
     * const buffer = borshSerialize(BorshSchema.u64, n);
     */
    static get u64(): BorshSchema;
    /**
     * Schema for u128.
     * @example
     * const n: bigint = 100n;
     *
     * const buffer = borshSerialize(BorshSchema.u128, n);
     */
    static get u128(): BorshSchema;
    /**
     * Schema for i8.
     * @example
     * const n: number = 100;
     *
     * const buffer = borshSerialize(BorshSchema.i8, n);
     */
    static get i8(): BorshSchema;
    /**
     * Schema for i16.
     * @example
     * const n: number = 100;
     *
     * const buffer = borshSerialize(BorshSchema.i16, n);
     */
    static get i16(): BorshSchema;
    /**
     * Schema for i32.
     * @example
     * const n: number = 100;
     *
     * const buffer = borshSerialize(BorshSchema.i32, n);
     */
    static get i32(): BorshSchema;
    /**
     * Schema for i64.
     * @example
     * const n: bigint = 100n;
     *
     * const buffer = borshSerialize(BorshSchema.i64, n);
     */
    static get i64(): BorshSchema;
    /**
     * Schema for i128.
     * @example
     * const n: bigint = 100n;
     *
     * const buffer = borshSerialize(BorshSchema.i128, n);
     */
    static get i128(): BorshSchema;
    /**
     * Schema for f32.
     * @example
     * const n: number = 1.0;
     *
     * const buffer = borshSerialize(BorshSchema.f32, n);
     */
    static get f32(): BorshSchema;
    /**
     * Schema for f64.
     * @example
     * const n: number = 1.0;
     *
     * const buffer = borshSerialize(BorshSchema.f64, n);
     */
    static get f64(): BorshSchema;
    /**
     * Schema for bool.
     * @example
     * const b: boolean = true;
     *
     * const buffer = borshSerialize(BorshSchema.bool, b);
     */
    static get bool(): BorshSchema;
    /**
     * Schema for String.
     * @example
     * const message: string = 'hello world';
     *
     * const buffer = borshSerialize(BorshSchema.String, message);
     */
    static get String(): BorshSchema;
    /**
     * Schema for Array.
     * @example
     * const schema = BorshSchema.Array(BorshSchema.String, 2);
     *
     * const messages: string[] = ['hello', 'world'];
     *
     * const buffer = borshSerialize(schema, messages);
     * @param ele Element
     * @param len Length
     */
    static Array(ele: BorshSchema, len: number): BorshSchema;
    /**
     * Schema for Vec.
     * @example
     * const schema = BorshSchema.Vec(BorshSchema.String);
     *
     * const messages: string[] = ['hello', 'world'];
     *
     * const buffer = borshSerialize(schema, messages);
     * @param ele Element
     */
    static Vec(ele: BorshSchema): BorshSchema;
    /**
     * Schema for HashSet.
     * @example
     * const schema = BorshSchema.HashSet(BorshSchema.String);
     *
     * const messages: Set<string> = new Set(['hello', 'world']);
     *
     * const buffer = borshSerialize(schema, messages);
     * @param ele Element
     */
    static HashSet(ele: BorshSchema): BorshSchema;
    /**
     * Schema for HashMap.
     * @example
     * const schema = BorshSchema.HashMap(BorshSchema.String, BorshSchema.u128);
     *
     * const balances: Map<string, bigint> = new Map([
     *   ['alice', 1_000_000_000_000_000_000_000_000n],
     *   ['bob', 2_000_000_000_000_000_000_000_000n]
     * ]);
     *
     * const buffer = borshSerialize(schema, balances);
     * @param k Key
     * @param v Value
     */
    static HashMap(k: BorshSchema, v: BorshSchema): BorshSchema;
    /**
     * Schema for Option.
     * @example
     * const schema = BorshSchema.Option(BorshSchema.String);
     *
     * const some: string | null = 'hello world';
     * const none: string | null = null;
     *
     * const someBuffer = borshSerialize(schema, some);
     * const noneBuffer = borshSerialize(schema, none);
     * @param v Value
     */
    static Option(v: BorshSchema): BorshSchema;
    /**
     * Schema for Unit.
     * @example
     * const unit: {} = {};
     *
     * const buffer = borshSerialize(BorshSchema.Unit, unit);
     */
    static get Unit(): BorshSchema;
    /**
     * Schema for Struct.
     * @example
     * interface Person {
     *   name: string;
     *   age: number;
     * }
     *
     * const schema = BorshSchema.Struct({
     *   name: BorshSchema.String,
     *   age: BorshSchema.u8
     * });
     *
     * const person: Person = {
     *   name: 'alice',
     *   age: 18
     * };
     *
     * const buffer = borshSerialize(schema, person);
     * @param fields Struct fields
     */
    static Struct(fields: StructFields): BorshSchema;
    /**
     * Schema for Enum.
     * @example
     * // enum without associated value
     * type Status =
     *   | {
     *       Pending: {};
     *     }
     *   | {
     *       Filled: {};
     *     }
     *   | {
     *       Cancelled: {};
     *     };
     *
     * const schema = BorshSchema.Enum({
     *   Pending: BorshSchema.Unit,
     *   Filled: BorshSchema.Unit,
     *   Cancelled: BorshSchema.Unit,
     * });
     *
     * const status: Status = {
     *   Pending: {}
     * };
     *
     * const buffer = borshSerialize(schema, status);
     * @example
     * // enum with associated value
     * type Shape =
     *   | {
     *       Square: number;
     *     }
     *   | {
     *       Rectangle: {
     *         length: number;
     *         width: number;
     *       };
     *     }
     *   | {
     *       Circle: {
     *         radius: number;
     *       };
     *     };
     *
     * const schema = BorshSchema.Enum({
     *   Square: BorshSchema.u32,
     *   Rectangle: BorshSchema.Struct({
     *     length: BorshSchema.u32,
     *     width: BorshSchema.u32
     *   }),
     *   Circle: BorshSchema.Struct({
     *     radius: BorshSchema.u32
     *   })
     * });
     *
     * const shape: Shape = {
     *   Square: 5
     * };
     *
     * const buffer = borshSerialize(schema, shape);
     * @param variants Enum variants
     */
    static Enum(variants: EnumVariants): BorshSchema;
}

export { BorshSchema, EnumVariants, StructFields };
